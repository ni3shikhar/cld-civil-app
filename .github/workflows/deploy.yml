# GitHub Actions Deployment Pipeline for Contoso Civil App
# Deploys infrastructure and application to Azure

name: Deploy to Azure

on:
  workflow_run:
    workflows: ["Build and Push Images"]
    branches: [main]
    types: [completed]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod
      deploy_infra:
        description: '1. Deploy infrastructure (Bicep)'
        required: false
        default: false
        type: boolean
      deploy_database:
        description: '2. Initialize database schema'
        required: false
        default: false
        type: boolean
      seed_database:
        description: '3. Load seed data into database'
        required: false
        default: false
        type: boolean
      run_migrations:
        description: '4. Run database migrations (incremental schema updates)'
        required: false
        default: false
        type: boolean
      build_images:
        description: '5. Build and push container images'
        required: false
        default: false
        type: boolean
      deploy_containers:
        description: '6. Update container apps with new images'
        required: false
        default: false
        type: boolean
      skip_approval:
        description: 'Skip approval gate (for dev/testing)'
        required: false
        default: false
        type: boolean

env:
  AZURE_SUBSCRIPTION: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  LOCATION: 'westus2'

jobs:
  # =====================================================
  # VALIDATION & APPROVAL
  # =====================================================
  validate-deployment:
    name: Validate Deployment
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch'
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      requires_approval: ${{ steps.set-env.outputs.requires_approval }}
    
    steps:
      - name: Set Environment
        id: set-env
        run: |
          ENV="${{ github.event.inputs.environment || 'dev' }}"
          SKIP_APPROVAL="${{ github.event.inputs.skip_approval }}"
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          
          # Staging and prod require approval unless skip_approval is true
          if [ "$SKIP_APPROVAL" == "true" ]; then
            echo "requires_approval=false" >> $GITHUB_OUTPUT
            echo "::notice::Approval gate skipped by user request"
          elif [ "$ENV" == "staging" ] || [ "$ENV" == "prod" ]; then
            echo "requires_approval=true" >> $GITHUB_OUTPUT
          else
            echo "requires_approval=false" >> $GITHUB_OUTPUT
          fi
      
      - name: Deployment Summary
        run: |
          echo "## Deployment Validation" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Deployment Steps" >> $GITHUB_STEP_SUMMARY
          echo "| Step | Enabled |" >> $GITHUB_STEP_SUMMARY
          echo "|------|---------|" >> $GITHUB_STEP_SUMMARY
          echo "| 1. Deploy Infrastructure | ${{ github.event.inputs.deploy_infra || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| 2. Initialize Database Schema | ${{ github.event.inputs.deploy_database || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| 3. Seed Database | ${{ github.event.inputs.seed_database || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| 4. Run Migrations | ${{ github.event.inputs.run_migrations || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| 5. Build Container Images | ${{ github.event.inputs.build_images || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| 6. Deploy Container Apps | ${{ github.event.inputs.deploy_containers || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Configuration" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Environment | ${{ github.event.inputs.environment || 'dev' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Skip Approval | ${{ github.event.inputs.skip_approval || 'false' }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Triggered By | ${{ github.actor }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Branch | ${{ github.ref_name }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Commit | ${{ github.sha }} |" >> $GITHUB_STEP_SUMMARY

  approval-gate:
    name: Approval Gate
    runs-on: ubuntu-latest
    needs: validate-deployment
    # Use environment with required reviewers for staging/prod
    environment: 
      name: ${{ needs.validate-deployment.outputs.environment }}-approval
    # Only require approval for staging/prod
    if: needs.validate-deployment.outputs.requires_approval == 'true'
    
    steps:
      - name: Approval Confirmed
        run: |
          echo "## âœ… Deployment Approved" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Approved by: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "Environment: ${{ needs.validate-deployment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "Time: $(date -u)" >> $GITHUB_STEP_SUMMARY

  # =====================================================
  # INFRASTRUCTURE DEPLOYMENT
  # =====================================================
  deploy-infrastructure:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [validate-deployment, approval-gate]
    # Run if approval passed OR if approval wasn't required (dev environment)
    if: always() && needs.validate-deployment.result == 'success' && (needs.approval-gate.result == 'success' || needs.approval-gate.result == 'skipped')
    environment: ${{ needs.validate-deployment.outputs.environment }}
    
    env:
      SQL_ADMIN_PASSWORD: ${{ secrets.SQL_ADMIN_PASSWORD }}
      SQL_ADMIN_LOGIN: ${{ secrets.SQL_ADMIN_LOGIN }}
      JWT_SECRET: ${{ secrets.JWT_SECRET }}
    
    outputs:
      acr_login_server: ${{ steps.deploy.outputs.acrLoginServer }}
      api_url: ${{ steps.deploy.outputs.apiGatewayUrl }}
      frontend_url: ${{ steps.deploy.outputs.frontendUrl }}
      sql_server: ${{ steps.deploy.outputs.sqlServerFqdn }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set Environment Variables
        id: env
        run: |
          ENV="${{ github.event.inputs.environment || 'dev' }}"
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "resource_group=${{ secrets.RESOURCE_GROUP }}" >> $GITHUB_OUTPUT

      - name: Validate Required Secrets
        run: |
          echo "Validating required secrets..."
          echo "SQL_ADMIN_PASSWORD length: ${#SQL_ADMIN_PASSWORD}"
          echo "SQL_ADMIN_LOGIN length: ${#SQL_ADMIN_LOGIN}"
          echo "JWT_SECRET length: ${#JWT_SECRET}"
          
          if [ -z "$SQL_ADMIN_PASSWORD" ] || [ ${#SQL_ADMIN_PASSWORD} -lt 8 ]; then
            echo "::error::SQL_ADMIN_PASSWORD is missing or too short (min 8 chars)"
            exit 1
          fi
          
          if [ -z "$SQL_ADMIN_LOGIN" ]; then
            echo "::warning::SQL_ADMIN_LOGIN not set, will use default 'sqladmin'"
          fi
          
          if [ -z "$JWT_SECRET" ]; then
            echo "::warning::JWT_SECRET not set"
          fi
          
          echo "Secrets validation passed"

      - name: Create Resource Group
        run: |
          az group create \
            --name "${{ secrets.RESOURCE_GROUP }}" \
            --location ${{ env.LOCATION }}

      - name: Deploy Bicep Template
        id: deploy
        if: github.event.inputs.deploy_infra == 'true'
        env:
          DEPLOY_ENV: ${{ steps.env.outputs.environment }}
          DEPLOY_RG: ${{ secrets.RESOURCE_GROUP }}
          DEPLOY_LOCATION: ${{ env.LOCATION }}
          RUN_ID: ${{ github.run_id }}
        run: |
          # Use default login if not set
          SQL_LOGIN="${SQL_ADMIN_LOGIN:-sqladmin}"
          
          # Debug: print password length (not value)
          echo "Password length: ${#SQL_ADMIN_PASSWORD}"
          echo "Login: $SQL_LOGIN"
          
          # Create parameters JSON file to handle special characters
          cat > params.json << 'PARAMS_EOF'
          {
            "environment": { "value": "PLACEHOLDER_ENV" },
            "location": { "value": "PLACEHOLDER_LOC" },
            "sqlAdminLogin": { "value": "PLACEHOLDER_LOGIN" },
            "sqlAdminPassword": { "value": "PLACEHOLDER_PWD" },
            "jwtSecret": { "value": "PLACEHOLDER_JWT" }
          }
          PARAMS_EOF
          
          # Replace placeholders with actual values using jq
          jq --arg env "$DEPLOY_ENV" \
             --arg loc "$DEPLOY_LOCATION" \
             --arg login "$SQL_LOGIN" \
             --arg pwd "$SQL_ADMIN_PASSWORD" \
             --arg jwt "$JWT_SECRET" \
             '.environment.value = $env | .location.value = $loc | .sqlAdminLogin.value = $login | .sqlAdminPassword.value = $pwd | .jwtSecret.value = $jwt' \
             params.json > params_final.json
          
          OUTPUT=$(az deployment group create \
            --name "deployment-$RUN_ID" \
            --resource-group "$DEPLOY_RG" \
            --template-file infra/main.bicep \
            --parameters @params_final.json \
            --output json)
          
          rm -f params.json params_final.json
          
          echo "acrLoginServer=$(echo $OUTPUT | jq -r '.properties.outputs.acrLoginServer.value')" >> $GITHUB_OUTPUT
          echo "apiGatewayUrl=$(echo $OUTPUT | jq -r '.properties.outputs.apiGatewayUrl.value')" >> $GITHUB_OUTPUT
          echo "frontendUrl=$(echo $OUTPUT | jq -r '.properties.outputs.frontendUrl.value')" >> $GITHUB_OUTPUT
          echo "sqlServerFqdn=$(echo $OUTPUT | jq -r '.properties.outputs.sqlServerFqdn.value')" >> $GITHUB_OUTPUT

      - name: Initialize Database Schema
        if: github.event.inputs.deploy_database == 'true'
        env:
          SQL_SERVER_OUTPUT: ${{ steps.deploy.outputs.sqlServerFqdn }}
          SQLCMDPASSWORD: ${{ secrets.SQL_ADMIN_PASSWORD }}
          RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }}
        run: |
          # Get SQL server FQDN - from deploy output or query Azure
          if [ -n "$SQL_SERVER_OUTPUT" ]; then
            SQL_SERVER="$SQL_SERVER_OUTPUT"
          else
            echo "Deploy output empty, querying Azure for SQL server..."
            SQL_SERVER=$(az sql server list -g "$RESOURCE_GROUP" --query "[0].fullyQualifiedDomainName" -o tsv)
          fi
          
          echo "SQL Server: $SQL_SERVER"
          echo "SQL_SERVER=$SQL_SERVER" >> $GITHUB_ENV
          echo "SQL_SERVER_NAME=$(echo $SQL_SERVER | cut -d'.' -f1)" >> $GITHUB_ENV
          
          if [ -z "$SQL_SERVER" ]; then
            echo "::error::Could not determine SQL Server FQDN"
            exit 1
          fi
          
          # Get SQL server name (without domain)
          SQL_SERVER_NAME=$(echo "$SQL_SERVER" | cut -d'.' -f1)
          
          # Get runner's public IP and add to SQL firewall
          RUNNER_IP=$(curl -s https://api.ipify.org)
          echo "Adding runner IP $RUNNER_IP to SQL firewall..."
          az sql server firewall-rule create \
            -g "$RESOURCE_GROUP" \
            -s "$SQL_SERVER_NAME" \
            -n "GitHubRunner-${{ github.run_id }}" \
            --start-ip-address "$RUNNER_IP" \
            --end-ip-address "$RUNNER_IP"
          
          # Install sqlcmd (modern keyring approach)
          curl -fsSL https://packages.microsoft.com/keys/microsoft.asc | sudo gpg --batch --yes --dearmor -o /usr/share/keyrings/microsoft-prod.gpg
          echo "deb [arch=amd64 signed-by=/usr/share/keyrings/microsoft-prod.gpg] https://packages.microsoft.com/ubuntu/22.04/prod jammy main" | sudo tee /etc/apt/sources.list.d/mssql-release.list
          sudo apt-get update
          sudo ACCEPT_EULA=Y apt-get install -y mssql-tools18 unixodbc-dev
          
          # Use default login if not set (SQL_ADMIN_LOGIN from job-level env)
          SQL_LOGIN="${SQL_ADMIN_LOGIN:-sqladmin}"
          
          # Azure SQL doesn't support CREATE DATABASE or USE statements
          # Remove lines 4-10 (DB creation and USE blocks) - connect directly to the database (created by Bicep)
          tail -n +11 database/schema.sql > database/azure-schema.sql
          
          # Run schema using SQLCMDPASSWORD env var (avoids shell escaping issues)
          echo "Running schema..."
          /opt/mssql-tools18/bin/sqlcmd \
            -S "$SQL_SERVER" \
            -U "$SQL_LOGIN" \
            -d ContosoCivilApp \
            -i database/azure-schema.sql \
            -C -b

      - name: Seed Database
        if: github.event.inputs.seed_database == 'true'
        env:
          SQL_SERVER_OUTPUT: ${{ steps.deploy.outputs.sqlServerFqdn }}
          SQLCMDPASSWORD: ${{ secrets.SQL_ADMIN_PASSWORD }}
          RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }}
        run: |
          # Get SQL server FQDN - from deploy output, env, or query Azure
          if [ -n "$SQL_SERVER" ]; then
            : # Already set from previous step
          elif [ -n "$SQL_SERVER_OUTPUT" ]; then
            SQL_SERVER="$SQL_SERVER_OUTPUT"
          else
            echo "Querying Azure for SQL server..."
            SQL_SERVER=$(az sql server list -g "$RESOURCE_GROUP" --query "[0].fullyQualifiedDomainName" -o tsv)
          fi
          
          SQL_SERVER_NAME=$(echo "$SQL_SERVER" | cut -d'.' -f1)
          echo "SQL Server: $SQL_SERVER"
          
          if [ -z "$SQL_SERVER" ]; then
            echo "::error::Could not determine SQL Server FQDN"
            exit 1
          fi
          
          # Check if sqlcmd is installed, if not install it
          if ! command -v /opt/mssql-tools18/bin/sqlcmd &> /dev/null; then
            echo "Installing sqlcmd..."
            curl -fsSL https://packages.microsoft.com/keys/microsoft.asc | sudo gpg --batch --yes --dearmor -o /usr/share/keyrings/microsoft-prod.gpg
            echo "deb [arch=amd64 signed-by=/usr/share/keyrings/microsoft-prod.gpg] https://packages.microsoft.com/ubuntu/22.04/prod jammy main" | sudo tee /etc/apt/sources.list.d/mssql-release.list
            sudo apt-get update
            sudo ACCEPT_EULA=Y apt-get install -y mssql-tools18 unixodbc-dev
          fi
          
          # Check if firewall rule exists, if not create it
          if ! az sql server firewall-rule show -g "$RESOURCE_GROUP" -s "$SQL_SERVER_NAME" -n "GitHubRunner-${{ github.run_id }}" &> /dev/null; then
            RUNNER_IP=$(curl -s https://api.ipify.org)
            echo "Adding runner IP $RUNNER_IP to SQL firewall..."
            az sql server firewall-rule create \
              -g "$RESOURCE_GROUP" \
              -s "$SQL_SERVER_NAME" \
              -n "GitHubRunner-${{ github.run_id }}" \
              --start-ip-address "$RUNNER_IP" \
              --end-ip-address "$RUNNER_IP"
          fi
          
          # Use default login if not set
          SQL_LOGIN="${SQL_ADMIN_LOGIN:-sqladmin}"
          
          # Strip USE statement from seed data (lines 3-4)
          tail -n +5 database/seed-data.sql > database/azure-seed-data.sql
          
          # Run seed data
          echo "Running seed data..."
          /opt/mssql-tools18/bin/sqlcmd \
            -S "$SQL_SERVER" \
            -U "$SQL_LOGIN" \
            -d ContosoCivilApp \
            -i database/azure-seed-data.sql \
            -C -b

      - name: Run Database Migrations
        if: github.event.inputs.run_migrations == 'true'
        env:
          SQL_SERVER_OUTPUT: ${{ steps.deploy.outputs.sqlServerFqdn }}
          SQLCMDPASSWORD: ${{ secrets.SQL_ADMIN_PASSWORD }}
          RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }}
        run: |
          # Get SQL server FQDN - from deploy output, env, or query Azure
          if [ -n "$SQL_SERVER" ]; then
            : # Already set from previous step
          elif [ -n "$SQL_SERVER_OUTPUT" ]; then
            SQL_SERVER="$SQL_SERVER_OUTPUT"
          else
            echo "Querying Azure for SQL server..."
            SQL_SERVER=$(az sql server list -g "$RESOURCE_GROUP" --query "[0].fullyQualifiedDomainName" -o tsv)
          fi
          
          SQL_SERVER_NAME=$(echo "$SQL_SERVER" | cut -d'.' -f1)
          echo "SQL Server: $SQL_SERVER"
          
          if [ -z "$SQL_SERVER" ]; then
            echo "::error::Could not determine SQL Server FQDN"
            exit 1
          fi
          
          # Check if sqlcmd is installed, if not install it
          if ! command -v /opt/mssql-tools18/bin/sqlcmd &> /dev/null; then
            echo "Installing sqlcmd..."
            curl -fsSL https://packages.microsoft.com/keys/microsoft.asc | sudo gpg --batch --yes --dearmor -o /usr/share/keyrings/microsoft-prod.gpg
            echo "deb [arch=amd64 signed-by=/usr/share/keyrings/microsoft-prod.gpg] https://packages.microsoft.com/ubuntu/22.04/prod jammy main" | sudo tee /etc/apt/sources.list.d/mssql-release.list
            sudo apt-get update
            sudo ACCEPT_EULA=Y apt-get install -y mssql-tools18 unixodbc-dev
          fi
          
          # Check if firewall rule exists, if not create it
          if ! az sql server firewall-rule show -g "$RESOURCE_GROUP" -s "$SQL_SERVER_NAME" -n "GitHubRunner-${{ github.run_id }}" &> /dev/null; then
            RUNNER_IP=$(curl -s https://api.ipify.org)
            echo "Adding runner IP $RUNNER_IP to SQL firewall..."
            az sql server firewall-rule create \
              -g "$RESOURCE_GROUP" \
              -s "$SQL_SERVER_NAME" \
              -n "GitHubRunner-${{ github.run_id }}" \
              --start-ip-address "$RUNNER_IP" \
              --end-ip-address "$RUNNER_IP"
          fi
          
          # Use default login if not set
          SQL_LOGIN="${SQL_ADMIN_LOGIN:-sqladmin}"
          
          # Run all migration files in order
          echo "Running database migrations..."
          MIGRATION_COUNT=0
          for migration_file in $(ls database/migrations/*.sql 2>/dev/null | sort); do
            echo "Running migration: $migration_file"
            /opt/mssql-tools18/bin/sqlcmd \
              -S "$SQL_SERVER" \
              -U "$SQL_LOGIN" \
              -d ContosoCivilApp \
              -i "$migration_file" \
              -C -b || echo "Warning: Migration $migration_file may have already been applied or encountered an error"
            MIGRATION_COUNT=$((MIGRATION_COUNT + 1))
          done
          
          if [ $MIGRATION_COUNT -eq 0 ]; then
            echo "No migration files found in database/migrations/"
          else
            echo "Completed $MIGRATION_COUNT migration(s)"
          fi

      - name: Cleanup SQL Firewall Rule
        if: always() && (github.event.inputs.deploy_database == 'true' || github.event.inputs.seed_database == 'true' || github.event.inputs.run_migrations == 'true')
        env:
          RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }}
          SQL_SERVER_OUTPUT: ${{ steps.deploy.outputs.sqlServerFqdn }}
        run: |
          # Get SQL server name
          if [ -n "$SQL_SERVER_NAME" ]; then
            : # Already set
          elif [ -n "$SQL_SERVER_OUTPUT" ]; then
            SQL_SERVER_NAME=$(echo "$SQL_SERVER_OUTPUT" | cut -d'.' -f1)
          else
            SQL_SERVER_NAME=$(az sql server list -g "$RESOURCE_GROUP" --query "[0].name" -o tsv)
          fi
          
          echo "Removing runner IP from SQL firewall..."
          az sql server firewall-rule delete \
            -g "$RESOURCE_GROUP" \
            -s "$SQL_SERVER_NAME" \
            -n "GitHubRunner-${{ github.run_id }}" || true

  deploy-containers:
    name: Build & Deploy Container Apps
    runs-on: ubuntu-latest
    needs: [validate-deployment, deploy-infrastructure]
    # Run if build_images or deploy_containers is enabled, even if infrastructure was skipped
    if: always() && needs.validate-deployment.result == 'success' && (github.event.inputs.build_images == 'true' || github.event.inputs.deploy_containers == 'true')
    environment: ${{ needs.validate-deployment.outputs.environment }}
    
    env:
      ACR_LOGIN_SERVER: ${{ needs.deploy-infrastructure.outputs.acr_login_server }}
      IMAGE_TAG: ${{ github.sha }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Login to ACR
        env:
          RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }}
        run: |
          # Get ACR login server from output or query Azure
          if [ -n "$ACR_LOGIN_SERVER" ]; then
            ACR_SERVER="$ACR_LOGIN_SERVER"
          else
            echo "ACR output empty, querying Azure..."
            ACR_SERVER=$(az acr list -g "$RESOURCE_GROUP" --query "[0].loginServer" -o tsv)
          fi
          
          echo "Logging into ACR: $ACR_SERVER"
          echo "ACR_SERVER=$ACR_SERVER" >> $GITHUB_ENV
          az acr login --name $(echo $ACR_SERVER | cut -d'.' -f1)

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Build and Push Images
        if: github.event.inputs.build_images == 'true'
        env:
          RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP }}
        run: |
          echo "Building and pushing images to $ACR_SERVER"
          
          # Get API Gateway URL for frontend build
          API_GATEWAY_URL=$(az containerapp show -n civil-api-gateway -g "$RESOURCE_GROUP" --query "properties.configuration.ingress.fqdn" -o tsv 2>/dev/null || echo "")
          if [ -n "$API_GATEWAY_URL" ]; then
            API_BASE_URL="https://${API_GATEWAY_URL}/api"
          else
            API_BASE_URL="http://localhost:3000/api"
          fi
          echo "Frontend will use API: $API_BASE_URL"
          
          # Build and push frontend (with API URL baked in)
          echo "Building frontend..."
          docker build -f .docker/Dockerfile.frontend \
            --build-arg REACT_APP_API_BASE_URL="$API_BASE_URL" \
            -t $ACR_SERVER/frontend:$IMAGE_TAG \
            -t $ACR_SERVER/frontend:latest .
          docker push $ACR_SERVER/frontend:$IMAGE_TAG
          docker push $ACR_SERVER/frontend:latest
          
          # Build and push api-gateway
          echo "Building api-gateway..."
          docker build -f .docker/Dockerfile.api-gateway -t $ACR_SERVER/api-gateway:$IMAGE_TAG -t $ACR_SERVER/api-gateway:latest .
          docker push $ACR_SERVER/api-gateway:$IMAGE_TAG
          docker push $ACR_SERVER/api-gateway:latest
          
          # Build and push backend services
          for service in user-service job-service interview-service application-service rate-analysis-service; do
            echo "Building $service..."
            docker build -f .docker/Dockerfile.services --build-arg SERVICE_NAME=$service -t $ACR_SERVER/$service:$IMAGE_TAG -t $ACR_SERVER/$service:latest .
            docker push $ACR_SERVER/$service:$IMAGE_TAG
            docker push $ACR_SERVER/$service:latest
          done

      - name: Update Container Apps
        if: github.event.inputs.deploy_containers == 'true'
        run: |
          # Container app names must match Bicep template (prefix='civil')
          declare -A APP_IMAGES=(
            ["civil-user-service"]="user-service"
            ["civil-job-service"]="job-service"
            ["civil-interview-service"]="interview-service"
            ["civil-app-svc"]="application-service"
            ["civil-rate-analysis"]="rate-analysis-service"
            ["civil-api-gateway"]="api-gateway"
            ["civil-frontend"]="frontend"
          )
          
          for app_name in "${!APP_IMAGES[@]}"; do
            image_name="${APP_IMAGES[$app_name]}"
            echo "Updating $app_name with image $image_name..."
            az containerapp update \
              --name "$app_name" \
              --resource-group "${{ secrets.RESOURCE_GROUP }}" \
              --image "$ACR_SERVER/$image_name:$IMAGE_TAG" \
              --output none || echo "Warning: Failed to update $app_name"
          done

      - name: Display Deployment URLs
        run: |
          echo "============================================"
          echo "Deployment Complete!"
          echo "============================================"
          echo "Frontend URL: ${{ needs.deploy-infrastructure.outputs.frontend_url }}"
          echo "API Gateway URL: ${{ needs.deploy-infrastructure.outputs.api_url }}"
          echo "============================================"

  notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs: [validate-deployment, approval-gate, deploy-infrastructure, deploy-containers]
    if: always()
    
    steps:
      - name: Deployment Summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.validate-deployment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Stage | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| Validation | ${{ needs.validate-deployment.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Approval | ${{ needs.approval-gate.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Infrastructure | ${{ needs.deploy-infrastructure.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| Container Apps | ${{ needs.deploy-containers.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### URLs" >> $GITHUB_STEP_SUMMARY
          echo "- Frontend: ${{ needs.deploy-infrastructure.outputs.frontend_url }}" >> $GITHUB_STEP_SUMMARY
          echo "- API: ${{ needs.deploy-infrastructure.outputs.api_url }}" >> $GITHUB_STEP_SUMMARY
